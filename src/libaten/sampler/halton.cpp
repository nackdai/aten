#include "sampler/halton.h"
#include "math/math.h"
#include "defs.h"

namespace aten {
    std::vector<uint32_t> Halton::PrimeNumbers;

    // 素数生成.
    void Halton::makePrimeNumbers(uint32_t maxNumber/*= MaxPrimeNumbers*/)
    {
        // エラトステネスの篩（ふるい）.
        // https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9

        // アルゴリズム.
        // ステップ 1.
        //        探索リストに2からxまでの整数を昇順で入れる.
        // ステップ 2.
        //        探索リストの先頭の数を素数リストに移動し、その倍数を探索リストから篩い落とす.
        // ステップ 3.
        //        上記の篩い落とし操作を探索リストの先頭値がxの平方根に達するまで行う.
        // ステップ 4.
        //        探索リストに残った数を素数リストに移動して処理終了.

        // 具体例　x=120 の場合
        // ステップ 1
        //        探索リスト = { 2から120まで }、探索リストの先頭値 = 2
        // ステップ 2 - 1
        //        素数リスト = { 2 }
        //        探索リスト = { 3から119までの奇数 }、探索リストの先頭値 = 3
        // ステップ 2 - 2
        //        素数リスト = { 2,3 }
        //        探索リスト = { 5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79,83,85,89,91,95,97,101,103,107,109,113,115,119 }
        //        探索リストの先頭値 = 5
        // ステップ 2 - 3
        //        素数リスト = { 2,3,5 }
        //        探索リスト = { 7,11,13,17,19,23,29,31,37,41,43,47,49,53,59,61,67,71,73,77,79,83,89,91,97,101,103,107,109,113,119 }
        //        探索リストの先頭値 = 7
        // ステップ 2 - 4
        //        素数リスト = { 2,3,5,7 }
        //        探索リスト = { 11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113 }
        //        探索リストの先頭値 = 11
        // ステップ 3
        //        探索リストの先頭値が sqrt(120) = 10.954 に達しているのでステップ4へ.
        // ステップ 4
        //        残った探索リストを素数リストに移動.
        //        素数リスト = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113 }


        uint32_t N = aten::clamp<uint32_t>(maxNumber, 2, MaxPrimeNumbers);

        // 探索リスト.
        //  0 : 素数リストに入る.
        //  1 : 素数リストに入らない.
        // まずは、すべて素数リストに入る可能性があるので、すべてゼロにしておく.
        std::vector<uint32_t> table;
        table.resize(N + 1, 0);

        // アルゴリズムとして 2 から始まる.

        // 探索リストの先頭の値が sqrt(N) に達したら終了.
        // -> sqrt(N) の倍数について探索したら終了.
        //    なぜなら、sqrt(N) の倍数について探索した時点で、sqrt(N) の倍数はふるいにかけられるので、先頭値は必ず、sqrt(N) の倍数を超える.
        // -> i は探索候補の数値になるので、i が sqrt(N) を超えるまで探索を続ければいいことになる.

        for (uint32_t i = 2; i * i <= N; i++) {
            if (table[i] == 0) {
                // iが素数リストに入る.

                // iの倍数をふるいにかける.
                //  i に i を足すと、i の次の i の倍数となる.
                //  i に i を足し続ければ、i の倍数となる.
                for (uint32_t n = i + i; n <= N; n += i) {
                    table[n] = 1;
                }
            }
        }

        // 最終的な素数リストに格納.
        for (uint32_t i = 2; i <= N; i++) {
            if (table[i] == 0) {
                // 0 なので、素数リスト入り.
                PrimeNumbers.push_back(i);
            }
        }
    }

    real Halton::nextSample()
    {
        // NOTE
        // https://en.wikipedia.org/wiki/Halton_sequence

        if (m_dimension >= PrimeNumbers.size()) {
            // 次元を超えることは許さない..
            AT_ASSERT(false);
            return aten::drand48();
        }

        real f = 1;
        real r = 0;

        const auto base = PrimeNumbers[m_dimension++];

        uint32_t i = m_idx;

        while (i > 0) {
            f = f / (real)base;
            r = r + f * (i % base);
            i = i / base;
        }

        return r;
    }
}
